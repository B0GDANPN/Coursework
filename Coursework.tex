\documentclass[12pt]{article}
\input{Preambles/preamble.tex}

\title{Методы ускорения перебора соединений таблиц в планировании SQL запросов} 
\author{НГУ, ММФ, 22126, Пьянзин Богдан}
\date{\today}

\begin{document}
\begin{flushleft}
\maketitle

\newpage


\section*{Структура курсовой работы}  % Звездочка убирает нумерацию заголовка
\addcontentsline{toc}{section}{Структура курсовой работы} % Добавляем в оглавление

\section*{Введение}
\begin{itemize}
    \item Актуальность темы.
    \item Цель исследования.
\end{itemize}

\section*{Основная часть}

\subsection*{Теоретические основы соединений таблиц в SQL запросах}
\begin{itemize}
    \item Определение и классификация соединений и планирование запроса.
    \item Задача выбора порядка соединений таблиц.
    \item Факторы, влияющие на производительность (размеры таблиц, статистики, индексы, типы данных и т.д.).
\end{itemize}

\subsection*{Методы ускорения перебора соединений таблиц}
\begin{itemize}
    \item Классические подходы.
    \item Реализация в \textbf{PostgreSQL}.
    \item Современные подходы. \textcolor{red}{\%TODO}
\end{itemize}

\subsection*{Сравнительный анализ методов ускорения \textcolor{red}{\%TODO}}
\begin{itemize}
    \item Преимущества и недостатки каждого метода \textcolor{red}{\%TODO}
\end{itemize}

\section*{Заключение \textcolor{red}{\%TODO}} 
\begin{itemize}
    \item Итоги работы.
    \item Рекомендации по применению методов.
    \item Перспективы исследований.
\end{itemize}

\section*{Список литературы}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\centering    \section*{Введение}
\centering    \subsection*{Актуальность темы}
\raggedright

Современные СУБД работают с большим объёмом информации и транзакций, использую для ввода запросов язык SQL. 
В процессе трансляции запрос превращается сначала в логическое представление в виде дерева, 
затем с помощью оптимизатора СУБД в физический план исполнения. Производительность СУБД напрямую зависят от качества
сгенерированного физического плана. Для создания "хорошего" плана, нужно решить одну решить или приблизить решение
NP полной задачи перебора соединений таблиц,так как он требует сложных вычислений и значительных затрат ресурсов.

Сложность задачи обусловлена тем, что количество возможных соединений(бинарных) с n таблицами
равно количеству бинарных дерьев с n листьями - Числа Каталана, которые
имеют экспоненциальную скорость роста.
В классических подходах используется динамическое программирование(DP)
и эвристический поиск для решения этой проблемы. Однако с ростом количества таблиц,
потребление памяти( для хранения промежуточных результатов) и временя планирования становятся
слишком велики. Эвристические методы не гарантируют оптимальность решения, так как
находят локальное оптимальные планы, но не гарантируют глобальное оптимальное решение.

Современные подходы предлагают использовать машинное обучение на основе статистик,
которые могут динамически меняться в процессе выполнения запроса. И создавать на их
основе оптимальные планы.

Таким образом, выбор неэффективного плана запроса может привести
к значительному замедлению работы системы, а процесс поиска хорошего решения является
нетривиальной задачей. В свою очередь оптимальный план позволяет эффективно исполнить
запрос, с приемлемым потреблением CPU, памяти, I/O, сетевых ресурсов(особенно актуально
для распределённых СУБД).


\centering \subsection*{Цель}
\raggedright
Цель данного исследования – выявить факторы, влияющие на выбор порядка 
соединений в запросах к СУБД, а также проанализировать классические и
современные подходы, применяемые для оптимизации данной задачи.
В рамках работы планируется:
\begin{itemize}
    \item Определить ключевые параметры, влияющие на производительность 
    операций соединения (размер таблиц, наличие индексов, тип соединения и др.).
    \item Разобрать механизмы планирования запросов в \textbf{PostgreSQL}.
    \item Рассмотреть традиционные методы планирования порядка соединений, 
    включая динамическое программирование, эвристические алгоритмы и генетические, 
    используемые в \textbf{PostgreSQL}, изучить их эффективность и ограничения 
    при увеличении числа соединений в запросе.
    \item Изучить современные подходы, основанные на машинном обучении, и их
    применение в автоматическом выборе порядка соединений.
    \item Провести сравнительный анализ эффективности различных методов и 
    выявить сценарии нагрузок, при которых каждый из них показывает наилучшие 
    результаты.
    \item Выработать критерии для выбора оптимального метода планирования соединений
    в зависимости от типа запроса и структуры данных.
\end{itemize}

Исследование позволит оценить, какие подходы обеспечивают наилучшую п
роизводительность SQL-запросов в различных условиях и предложить рекомендации 
по их применению. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\centering \section*{Основная часть}
\centering \subsection*{Теоретические основы соединений таблиц в SQL запросах}
\centering \subsubsection*{Определение и классификация соединений в планировании запроса}
\raggedright
\textbf{Соединение таблиц} -- это операция, которая позволяет объединять данные
из двух и более таблиц по определённому условию. Использование соединений необходимо,
когда информация распределена между несколькими таблицами. В процессе работы оптимизатора,
решается вопрос какой тип соединения использовать и в каком порядке сое. 
Существуют три типа соединений:
\begin{description}
    \item[Nested Loop Join] -- выполняет вложенный перебор строк. 
    Для каждой строки из левой таблицы проходится по всем строкам правой таблицы 
    и ищет соответствующие строки по условию соединения. Пусть левая таблица 
    занимает M страниц и имеет m кортрежей, правая N, n соответственно. Имеется 
    варианты NLJ:
    \begin{description}
        \item[Наивный NLJ] -- перебирает каждый кортеж левой таблицы, 
        сравнивая с каждым из правой. Сложность $O(M+(m*N))$. Работает медленно 
        если таблицы большие, но прост в реализации, эффективен при малых 
        таблицах.
        \item[Индексированный NLJ] -- правая таблица имеет индекс по соединяемому 
        полю. Сложность $O(M+(m*log(n))$. Может значительно ускорить поиск, если 
        правая таблица большая. Но будет всё ещё медленным если левая таблица 
        большая.
        \item[Блочный поиск] -- улучшенная версия наивного NLJ, при
        ограничении памяти в буфере. Пусть доступно B буферов. Загружаем B-2 
        блоков из левой таблицы, 1 буфер для правой таблицы, 1 под результат. 
        Для каждой страницы из из буферов для правой таблицы, проверяем условие 
        с каждой строкой из буфера правой страницы, проходимся одним буфером по 
        всей правой таблице. Сложность $O(M + [M/(B-2)] * N)$.
    \end{description}
    \item[Merge Join] --  таблицы сортируются по ключу соединения, происходит 
    построчное  слияние таблиц. Очень хорошо работает если таблицы отсортированы 
    и/или есть индекс по ключу, лучше чем NLJ на больших таблицах. 
    Недостатки: потребность в сортировке, нужно память для хранения 
    отсортированных таблиц. Сложность $O(стоимость сортировки двух таблиц + M + N)$.
    \item[Hash Join] -- строится хэш-таблица для меньшей таблицы, перебирается 
    каждая строка в большей таблице и проверяется соответствие в хэш таблице. 
    Сложность $O(M+N)$. Работает хорошо одна таблица большая другая маленькая и 
    условие на равенство($=$). Недостатки: требует память для хэш-таблицы, плохо 
    работает если условие на есть диапазон.
\end{description}
Перечисленные выше способы соединения имеют разную эффективность, напрямую зависящую
от статистик. Выбор неоптимального типа соединения может привести к значительному 
ухудшению стоимости исполнения плана. Определение нужного типа происходит в процессе
оптимазации, то есть перевода лоогического дерева в физическое 

\centering \subsubsection*{Задача выбора порядка соединений}
\raggedright

С увеличением количества данных в СУБД увеличивается и время, необходимое для 
выполнения запросов. Сокращение времени выполнения запросов становится решающим 
фактором для повышения удобства и эффективности работы пользователей. СУБД 
преобразует запрос в набор планов. Каждый план представлен в виде дерева, узлами 
в которых являются данные из таблиц или результат соединения таблиц по условию, 
в общем случае называется отношением. Рёбра — условия соединения отношений.
При этом операция соединения отношений не ассоциативна, то есть
$(R1 \times R2) \times R3 \neq R1 \times (R2 \times R3)$ по стоимости.
В статье  [https://ruor.uottawa.ca/items/9898a486-a7ea-42af-a6d9-66b165a90e33] приводится
пример разной стоимости для двух деревьев соединений.
\begin{center}
    \begin{tikzpicture}
        % Первое дерево (Cost: 1000)
        \node (root1) {\textbf{Cost:1000}}
            child { node {Loop Join} 
                child { node {Hash Join} 
                    child { node {Table A} }
                    child { node {Table B} }
                }
                child { node {Table C} }
            }
            child { node {Table D} };
    
        % Второе дерево (Cost: 3000)
        \node (root2) [right=6cm of root1] {\textbf{Cost:3000}}
            child { node {Loop Join} 
                child { node {Hash Join} 
                    child { node {Table A} }
                    child { node {Table C} }
                }
                child { node {Table B} }
            }
            child { node {Table D} };
    \end{tikzpicture}
    \end{center}

Выбор в какой последовательности нужно соединить таблицы является задачей выбора 
порядка соединений. Различные планы запросов для одного и того же SQL возвращают 
одинаковый результат, но время и ресурсы (CPU, память, I/O обращения, возможно 
сетевые ресурсы), необходимые для выполнения запроса, сильно различаются. Поэтому 
выбор оптимального плана позволяет сократить время отклика, минимизировать 
потребление ресурсов и эффективно обрабатывать большие массивы данных, значительно 
повышая удобство работы пользователя.
\newline

    Задача планировщика/оптимизатора — построить наилучший план выполнения. 
Если это не требует больших вычислений, оптимизатор запросов будет перебирать 
все возможные варианты планов, чтобы в итоге выбрать тот,который имеет наименьшую 
стоимость. Например, если для обрабатываемого отношения создан индекс, прочитать 
отношение можно двумя способами. Во-первых, можно выполнить простое последовательное 
сканирование, а во-вторых, можно использовать индекс. Затем оценивается стоимость 
каждого варианта и выбирается самый дешёвый. Затем выбранный вариант 
разворачивается в полноценный план, который сможет использовать исполнитель. 
Мы примем, что уже получена стоимость каждого оператора сканирования.

\centering \subsubsection*{Факторы влияющие на производительность}
\raggedright

Исходя из классификации типов соединений при планировании запроса нужно иметь 
статистику: по размеру таблиц подаваемых на вход оператору, наличию индексов, наличие сортировки данных. 
Применение некоторых типов может потребовать дополнительной памяти.
Помимо этого существуют следующие факторы:
\begin{description}
    \item[Размер отношений (кардинальность таблицы)] -- количество отдельных строк 
    в таблице базы данных. Если таблица большая, выполнение соединения с ней может 
    быть дорогим, если же таблица маленькая, её можно поместить в память (in-memory), 
    и не придётся обращаться к внешней памяти, что может повлиять на стоимость.
    плана.
    \item[Кардинальность условия( селективнось соединения)] -- количество строк, оставшихся после фильтрации. 
    Наиболее селективные соединения следуют применять как можно раньше, так стоимость 
    оператора соединения это стоимость дочерних операторов $+$ собственная обработка.
    \item[Селективность столбцов] -- уникальность значений в столбце. 
    Высокая селективность - много уникальных значений, низкая селективность - мало уникальных значений.
    \item[Корреляция столбцов] -- зависимость значений между столбцами. 
    Если данные сильно коррелируют, оптимизатор может дать неправильную оценку 
    оператору соединения. Тогда ошибка распространиться на операторы стоящие выше,
    что приведёт к ошибке в оценке стоимости исполнения всего плана.
    \item[Распределение данных по столбцам] -- оказывает влияние корреляцию данных, селективность
    соединения. Зная распределение, оптимизатор может делать предположения, как
    данных хранятся в отношениях: есть ли отсортированность, использовать последовательное
    сканирование или индекс для поиска.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\centering \subsection*{Методы ускорения перебора соединений таблиц}
\raggedright

СУБД применяют классические и современные подходы к оптимизации 
порядка соединений.
\newline
Классические алгоритмы включают в себя:
\begin{itemize}
\item Методы ДП, выполняющие полный поиск среди всех возможных порядков
соединения, но требуют больших затрат памяти и зачачтую имеют плохую
ассимптотическую сложность.
\item Эвристические методы, требуют меньщих затра ресурсов по сравнению
с ДП, но находят приблизительно (локально) оптимальные планы.
\end{itemize}
Современные методы машинного обучения (ML) включают в себя:
\begin{itemize}
\item Обучение с подкреплением (Reinforcement Learning), позволяющее 
адаптивно находить оптимальный порядок соединений на основе исторических 
данных и дообучасться в процессе работы.
\item Специальные модели СУБД, запоминающие часть истории запросов и использующие их
для дообучения.
\end{itemize}

\centering \subsubsection*{Классические подходы}
\raggedright
Данные подходы в большинстве своём представляют алгоритмы динамического
прогаммирования и эвристические.
\newline
Основная идея методов ДП в том чтобы разбить задачу поиска оптимального
порядка на меньшие(по размеру соединяемых отношений) и решить оптимально их. Затем 
объединить в более крупные и так далее, пока не получим оптимальное решение 
для текущего запроса.
\newline
С другой стороны эвристический поиск по определённому предположению выбирает
"выгодные" планы, отсеивая "плохие", на каждом шаге. Зачастую это позволяет
получить приблизительно оптимальный план.
\newline
В данной работе рассмотрим следующие алгоритмы ДП: DPsize, DPsub, DPccp, 
DPhyp, IK/KBZ и LinearizedDP. А также эвристические алгоритмы GOO(Greedy Operator Ordering) и 
Geqo.

\centering \subsubsection*{DPsize [[https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de]]} 
\raggedright

Строит оптимальное \textbf{ветвистое дерево} ( такое дерево, что хотя бы у одной вершины,
начиная с корня, оба потомка составные отношения, т.е не являются таблицами)
снизу вверх, начиная с маленьких соединений и расширяя их. Имеет существенное ограничение -- 
не поддерживает работу с внешними соединениями, т.к они не коммутативны.


Изначально B хранит каждое отношение $R_i$ как лучший план для $R_i$. 
Затем начинается перебор всех подмножеств размера $\abs{s}$ возможных 
планов от 2 до n. Перебираются всевозможные разбиения S на непересекающиеся 
множества $S_1$, $S_2$, такие что существует хотя бы пара отношений в $S_1$ 
и $S_2$, связанная между собой условием соединения. Так как $\abs{S_1}$ и 
$\abs{S_2}$ меньше $\abs{s}$, то известны их оптимальные планы $p_1$ и $p_2$ соответственно. 
Стоимость объединения $p_1$ и $p_2$ меньше дешевле старой комбинации $S_1$ и 
$S_2$,  то происходит замена. Псевдокод:

\begin{algorithm}
    \caption{DPsize($R$)}
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$ to be joined
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} $1 < s \leq n$ \textbf{ascending}}
            \For{\textbf{each} $S_1, S_2 \subset R$ \textbf{such that} $|S_1| + |S_2| = s$}
                \If{(\textbf{not} cross products $\land \neg S_1$ connected to $S_2$) $\lor$ $(S_1 \cap S_2 \neq \emptyset)$}
                    \State \textbf{continue}
                \EndIf
                \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
                \If{$p_1 = \epsilon$ \textbf{or} $p_2 = \epsilon$} \textbf{continue} \EndIf
                \State $P \gets$ CreateJoinTree($p_1, p_2$)
                \If{$B[S_1 \cup S_2] = \epsilon$ \textbf{or} $C(B[S_1 \cup S_2]) > C(P)$}
                    \State $B[S_1 \cup S_2] \gets P$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

Сложность DPsize[https://dsg.uwaterloo.ca/seminars/notes/Guido.pdf]:

% Первая функция (I_chain)
\[
I^{\text{chain}}_{\text{DPsize}}(n) =
\begin{cases}
    \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 12n), & n \text{ even} \\
    \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 6n + 11), & n \text{ odd}
\end{cases}
\]

% Вторая функция (I_cycle)
\[
I^{\text{cycle}}_{\text{DPsize}}(n) =
\begin{cases}
    \frac{1}{4} (n^4 - n^3 - n^2), & n \text{ even} \\
    \frac{1}{4} (n^4 - n^3 - n^2 + n), & n \text{ odd}
\end{cases}
\]

% Третья функция (I_star)
\[
I^{\text{star}}_{\text{DPsize}}(n) =
\begin{cases}
    2^{2n-4} - \frac{1}{4} \binom{2n}{n-1} + q(n), & n \text{ even} \\
    2^{2n-4} - \frac{1}{4} \binom{2(n-1)}{(n-1)} + \frac{1}{4} \binom{(n-1)}{(n-1)/2} + q(n), & n \text{ odd}
\end{cases}
\]

% Функция q(n)
\[
\text{with } q(n) = n 2^{2n-1} - 5 \times 2^{n-3} + \frac{1}{2} (2^n - 5n + 4)
\]

% Четвёртая функция (I_clique)
\[
I^{\text{clique}}_{\text{DPsize}}(n) =
\begin{cases}
    2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} - \frac{1}{4} \binom{n}{n/2} + 1, & n \text{ even} \\
    2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} + 1, & n \text{ odd}
\end{cases}
\]
Где \textbf{chain} - запросы соединения от n таблиц, имеющие вид цепочки. 
\textbf{Cycle, star, clique} -- цикл, звезда(одна вершина связана со многими, все остальные
между собой не имеют связей), полный граф.

\centering \subsubsection*{DPsub [[https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de]]} 
\raggedright

\end{flushleft}
\end{document}
