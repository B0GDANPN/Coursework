\documentclass[12pt]{article}
\input{Preambles/preamble.tex}

\title{Методы ускорения перебора соединений таблиц в планировании SQL запросов} 
\author{НГУ, ММФ, 22126, Пьянзин Богдан}
\date{\today}

\begin{document}
\begin{flushleft}
\maketitle

\newpage


\section*{Структура курсовой работы}  % Звездочка убирает нумерацию заголовка
\addcontentsline{toc}{section}{Структура курсовой работы} % Добавляем в оглавление

\section*{Введение}
\begin{itemize}
    \item Актуальность темы.
    \item Цель исследования.
\end{itemize}

\section*{Основная часть}

\subsection*{Теоретические основы соединений таблиц в SQL запросах}
\begin{itemize}
    \item Определение и классификация соединений и планирование запроса.
    \item Задача выбора порядка соединений таблиц.
    \item Факторы, влияющие на производительность (размеры таблиц, статистики, индексы, типы данных и т.д.).
\end{itemize}

\subsection*{Методы ускорения перебора соединений таблиц}
\begin{itemize}
    \item Классические подходы.
    \item Реализация в \textbf{PostgreSQL}.
    \item Современные подходы. \textcolor{red}{\%TODO}
\end{itemize}

\subsection*{Сравнительный анализ методов ускорения \textcolor{red}{\%TODO}}
\begin{itemize}
    \item Преимущества и недостатки каждого метода \textcolor{red}{\%TODO}
\end{itemize}

\section*{Заключение \textcolor{red}{\%TODO}} 
\begin{itemize}
    \item Итоги работы.
    \item Рекомендации по применению методов.
    \item Перспективы исследований.
\end{itemize}

\section*{Список литературы}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\centering    \section*{Введение}
\centering    \subsection*{Актуальность темы}
\raggedright

Современные СУБД работают с большим объёмом информации и транзакций, использую для ввода запросов язык SQL. 
В процессе трансляции запрос превращается сначала в логическое представление в виде дерева, 
затем с помощью оптимизатора СУБД в физический план исполнения. Производительность СУБД напрямую зависят от качества
сгенерированного физического плана. Для создания "хорошего" плана, нужно решить одну решить или приблизить решение
NP полной задачи перебора соединений таблиц,так как он требует сложных вычислений и значительных затрат ресурсов.

Сложность задачи обусловлена тем, что количество возможных соединений(бинарных) с n таблицами
равно количеству бинарных дерьев с n листьями - Числа Каталана, которые
имеют экспоненциальную скорость роста.
В классических подходах используется динамическое программирование(DP)
и эвристический поиск для решения этой проблемы. Однако с ростом количества таблиц,
потребление памяти( для хранения промежуточных результатов) и временя планирования становятся
слишком велики. Эвристические методы не гарантируют оптимальность решения, так как
находят локальное оптимальные планы, но не гарантируют глобальное оптимальное решение.

Современные подходы предлагают использовать машинное обучение на основе статистик,
которые могут динамически меняться в процессе выполнения запроса. И создавать на их
основе оптимальные планы.

Таким образом, выбор неэффективного плана запроса может привести
к значительному замедлению работы системы, а процесс поиска хорошего решения является
нетривиальной задачей. В свою очередь оптимальный план позволяет эффективно исполнить
запрос, с приемлемым потреблением CPU, памяти, I/O, сетевых ресурсов(особенно актуально
для распределённых СУБД).


\centering \subsection*{Цель}
\raggedright
Цель данного исследования – выявить факторы, влияющие на выбор порядка 
соединений в запросах к СУБД, а также проанализировать классические и
современные подходы, применяемые для оптимизации данной задачи.
В рамках работы планируется:
\begin{itemize}
    \item Определить ключевые параметры, влияющие на производительность 
    операций соединения (размер таблиц, наличие индексов, тип соединения и др.).
    \item Разобрать механизмы планирования запросов в \textbf{PostgreSQL}.
    \item Рассмотреть традиционные методы планирования порядка соединений, 
    включая динамическое программирование, эвристические алгоритмы и генетические, 
    используемые в \textbf{PostgreSQL}, изучить их эффективность и ограничения 
    при увеличении числа соединений в запросе.
    \item Изучить современные подходы, основанные на машинном обучении, и их
    применение в автоматическом выборе порядка соединений.
    \item Провести сравнительный анализ эффективности различных методов и 
    выявить сценарии нагрузок, при которых каждый из них показывает наилучшие 
    результаты.
    \item Выработать критерии для выбора оптимального метода планирования соединений
    в зависимости от типа запроса и структуры данных.
\end{itemize}

Исследование позволит оценить, какие подходы обеспечивают наилучшую п
роизводительность SQL-запросов в различных условиях и предложить рекомендации 
по их применению. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\centering \section*{Основная часть}
\centering \subsection*{Теоретические основы соединений таблиц в SQL запросах}
\centering \subsubsection*{Определение и классификация соединений в планировании запроса}
\raggedright
\textbf{Соединение таблиц} -- это операция, которая позволяет объединять данные
из двух и более таблиц по определённому условию. Использование соединений необходимо,
когда информация распределена между несколькими таблицами. В процессе работы оптимизатора,
решается вопрос какой тип соединения использовать и в каком порядке сое. 
Существуют три типа соединений:
\begin{description}
    \item[Nested Loop Join] -- выполняет вложенный перебор строк. 
    Для каждой строки из левой таблицы проходится по всем строкам правой таблицы 
    и ищет соответствующие строки по условию соединения. Пусть левая таблица 
    занимает M страниц и имеет m кортрежей, правая N, n соответственно. Имеется 
    варианты NLJ:
    \begin{description}
        \item[Наивный NLJ] -- перебирает каждый кортеж левой таблицы, 
        сравнивая с каждым из правой. Сложность $O(M+(m*N))$. Работает медленно 
        если таблицы большие, но прост в реализации, эффективен при малых 
        таблицах.
        \item[Индексированный NLJ] -- правая таблица имеет индекс по соединяемому 
        полю. Сложность $O(M+(m*log(n)))$. Может значительно ускорить поиск, если 
        правая таблица большая. Но будет всё ещё медленным если левая таблица 
        большая.
        \item[Блочный поиск] -- улучшенная версия наивного NLJ, при
        ограничении памяти в буфере. Пусть доступно B буферов. Загружаем B-2 
        блоков из левой таблицы, 1 буфер для правой таблицы, 1 под результат. 
        Для каждой страницы из из буферов для правой таблицы, проверяем условие 
        с каждой строкой из буфера правой страницы, проходимся одним буфером по 
        всей правой таблице. Сложность $O(M + [M/(B-2)] * N)$.
    \end{description}
    \item[Merge Join] --  таблицы сортируются по ключу соединения, происходит 
    построчное  слияние таблиц. Очень хорошо работает если таблицы отсортированы 
    и/или есть индекс по ключу, лучше чем NLJ на больших таблицах. 
    Недостатки: потребность в сортировке, нужно память для хранения 
    отсортированных таблиц. Сложность $O(стоимость сортировки двух таблиц + M + N)$.
    \item[Hash Join] -- строится хэш-таблица для меньшей таблицы, перебирается 
    каждая строка в большей таблице и проверяется соответствие в хэш таблице. 
    Сложность $O(M+N)$. Работает хорошо одна таблица большая другая маленькая и 
    условие на равенство($=$). Недостатки: требует память для хэш-таблицы, плохо 
    работает если условие на есть диапазон.
\end{description}
Перечисленные выше способы соединения имеют разную эффективность, напрямую зависящую
от статистик. Выбор неоптимального типа соединения может привести к значительному 
ухудшению стоимости исполнения плана. Определение нужного типа происходит в процессе
оптимазации, то есть перевода лоогического дерева в физическое 

\centering \subsubsection*{Задача выбора порядка соединений}
\raggedright

С увеличением количества данных в СУБД увеличивается и время, необходимое для 
выполнения запросов. Сокращение времени выполнения запросов становится решающим 
фактором для повышения удобства и эффективности работы пользователей. СУБД 
преобразует запрос в набор планов. Каждый план представлен в виде дерева, узлами 
в которых являются данные из таблиц или результат соединения таблиц по условию, 
в общем случае называется отношением. Рёбра — условия соединения отношений.
При этом операция соединения отношений не ассоциативна, то есть
$(R1 \times R2) \times R3 \neq R1 \times (R2 \times R3)$ по стоимости.
В статье  [https://ruor.uottawa.ca/items/9898a486-a7ea-42af-a6d9-66b165a90e33] приводится
пример разной стоимости для двух деревьев соединений.
\begin{center}
    \begin{tikzpicture}
        % Первое дерево (Cost: 1000)
        \node (root1) {\textbf{Cost:1000}}
            child { node {Loop Join} 
                child { node {Hash Join} 
                    child { node {Table A} }
                    child { node {Table B} }
                }
                child { node {Table C} }
            }
            child { node {Table D} };
    
        % Второе дерево (Cost: 3000)
        \node (root2) [right=6cm of root1] {\textbf{Cost:3000}}
            child { node {Loop Join} 
                child { node {Hash Join} 
                    child { node {Table A} }
                    child { node {Table C} }
                }
                child { node {Table B} }
            }
            child { node {Table D} };
    \end{tikzpicture}
    \end{center}

Выбор в какой последовательности нужно соединить таблицы является задачей выбора 
порядка соединений. Различные планы запросов для одного и того же SQL возвращают 
одинаковый результат, но время и ресурсы (CPU, память, I/O обращения, возможно 
сетевые ресурсы), необходимые для выполнения запроса, сильно различаются. Поэтому 
выбор оптимального плана позволяет сократить время отклика, минимизировать 
потребление ресурсов и эффективно обрабатывать большие массивы данных, значительно 
повышая удобство работы пользователя.
\newline

    Задача планировщика/оптимизатора — построить наилучший план выполнения. 
Если это не требует больших вычислений, оптимизатор запросов будет перебирать 
все возможные варианты планов, чтобы в итоге выбрать тот,который имеет наименьшую 
стоимость. Например, если для обрабатываемого отношения создан индекс, прочитать 
отношение можно двумя способами. Во-первых, можно выполнить простое последовательное 
сканирование, а во-вторых, можно использовать индекс. Затем оценивается стоимость 
каждого варианта и выбирается самый дешёвый. Затем выбранный вариант 
разворачивается в полноценный план, который сможет использовать исполнитель. 
Мы примем, что уже получена стоимость каждого оператора сканирования.

\centering \subsubsection*{Факторы влияющие на производительность}
\raggedright

Исходя из классификации типов соединений при планировании запроса нужно иметь 
статистику: по размеру таблиц подаваемых на вход оператору, наличию индексов, наличие сортировки данных. 
Применение некоторых типов может потребовать дополнительной памяти.
Помимо этого существуют следующие факторы:
\begin{description}
    \item[Размер отношений (кардинальность таблицы)] -- количество отдельных строк 
    в таблице базы данных. Если таблица большая, выполнение соединения с ней может 
    быть дорогим, если же таблица маленькая, её можно поместить в память (in-memory), 
    и не придётся обращаться к внешней памяти, что может повлиять на стоимость.
    плана.
    \item[Кардинальность условия( селективнось соединения)] -- количество строк, оставшихся после фильтрации. 
    Наиболее селективные соединения следуют применять как можно раньше, так стоимость 
    оператора соединения это стоимость дочерних операторов $+$ собственная обработка.
    \item[Селективность столбцов] -- уникальность значений в столбце. 
    Высокая селективность - много уникальных значений, низкая селективность - мало уникальных значений.
    \item[Корреляция столбцов] -- зависимость значений между столбцами. 
    Если данные сильно коррелируют, оптимизатор может дать неправильную оценку 
    оператору соединения. Тогда ошибка распространиться на операторы стоящие выше,
    что приведёт к ошибке в оценке стоимости исполнения всего плана.
    \item[Распределение данных по столбцам] -- оказывает влияние корреляцию данных, селективность
    соединения. Зная распределение, оптимизатор может делать предположения, как
    данных хранятся в отношениях: есть ли отсортированность, использовать последовательное
    сканирование или индекс для поиска.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\centering \subsection*{Методы ускорения перебора соединений таблиц}
\raggedright

СУБД применяют классические и современные подходы к оптимизации 
порядка соединений.
\newline
Классические алгоритмы включают в себя:
\begin{itemize}
\item Методы ДП, выполняющие полный поиск среди всех возможных порядков
соединения, но требуют больших затрат памяти и зачачтую имеют плохую
ассимптотическую сложность.
\item Эвристические методы, требуют меньщих затра ресурсов по сравнению
с ДП, но находят приблизительно (локально) оптимальные планы.
\end{itemize}
Современные методы машинного обучения (ML) включают в себя:
\begin{itemize}
\item Обучение с подкреплением (Reinforcement Learning), позволяющее 
адаптивно находить оптимальный порядок соединений на основе исторических 
данных и дообучасться в процессе работы.
\item Специальные модели СУБД, запоминающие часть истории запросов и использующие их
для дообучения.
\end{itemize}

\centering \subsubsection*{Классические подходы}
\raggedright
Данные подходы в большинстве своём представляют алгоритмы динамического
прогаммирования и эвристические.
\newline
Основная идея методов ДП в том чтобы разбить задачу поиска оптимального
порядка на меньшие(по размеру соединяемых отношений) и решить оптимально их. Затем 
объединить в более крупные и так далее, пока не получим оптимальное решение 
для текущего запроса.
\newline
С другой стороны эвристический поиск по определённому предположению выбирает
"выгодные" планы, отсеивая "плохие", на каждом шаге. Зачастую это позволяет
получить приблизительно оптимальный план.
\newline
В данной работе рассмотрим следующие алгоритмы ДП: DPsize, DPsub, DPccp, 
DPhyp и LinDP++. А также эвристические алгоритмы GOO(Greedy Operator Ordering) и 
Geqo. Помимо этого разберём как работает планироващик в \textbf{PostgreSQL}.

\centering \subsubsection*{DPsize [https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de]} 
\raggedright

Строит оптимальное \textbf{ветвистое дерево} ( такое дерево, что хотя бы у одной вершины,
начиная с корня, оба потомка составные отношения, т.е не являются таблицами)
снизу вверх, начиная с маленьких соединений и расширяя их. Имеет существенное ограничение -- 
не поддерживает работу с внешними соединениями, т.к они не коммутативны.


Изначально B хранит каждое отношение $R_i$ как лучший план для $R_i$. 
Затем начинается перебор всех подмножеств размера $\abs{s}$ возможных 
планов от 2 до n. Перебираются всевозможные разбиения S на непересекающиеся 
множества $S_1$, $S_2$, такие что существует хотя бы пара отношений в $S_1$ 
и $S_2$, связанная между собой условием соединения. Так как $\abs{S_1}$ и 
$\abs{S_2}$ меньше $\abs{s}$, то известны их оптимальные планы $p_1$ и $p_2$ соответственно. 
Стоимость объединения $p_1$ и $p_2$ меньше дешевле старой комбинации $S_1$ и 
$S_2$,  то происходит замена.

\begin{algorithm}
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$ to be joined
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} $1 < s \leq n$ \textbf{ascending}}
            \For{\textbf{each} $S_1, S_2 \subset R$ \textbf{such that} $|S_1| + |S_2| = s$}
                \If{(\textbf{not} cross products $\land \neg S_1$ connected to $S_2$) $\lor$ $(S_1 \cap S_2 \neq \emptyset)$}
                    \State \textbf{continue}
                \EndIf
                \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
                \If{$p_1 = \epsilon$ \textbf{or} $p_2 = \epsilon$} \textbf{continue} \EndIf
                \State $P \gets$ CreateJoinTree($p_1, p_2$)
                \If{$B[S_1 \cup S_2] = \epsilon$ \textbf{or} $C(B[S_1 \cup S_2]) > C(P)$}
                    \State $B[S_1 \cup S_2] \gets P$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

Сложность DPsize[https://dsg.uwaterloo.ca/seminars/notes/Guido.pdf]:

% Первая функция (I_chain)
\[
I^{\text{chain}}_{\text{DPsize}}(n) =
\begin{cases}
    \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 12n), & n \text{ even} \\
    \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 6n + 11), & n \text{ odd}
\end{cases}
\]

% Вторая функция (I_cycle)
\[
I^{\text{cycle}}_{\text{DPsize}}(n) =
\begin{cases}
    \frac{1}{4} (n^4 - n^3 - n^2), & n \text{ even} \\
    \frac{1}{4} (n^4 - n^3 - n^2 + n), & n \text{ odd}
\end{cases}
\]

% Третья функция (I_star)
\[
I^{\text{star}}_{\text{DPsize}}(n) =
\begin{cases}
    2^{2n-4} - \frac{1}{4} \binom{2n}{n-1} + q(n), & n \text{ even} \\
    2^{2n-4} - \frac{1}{4} \binom{2(n-1)}{(n-1)} + \frac{1}{4} \binom{(n-1)}{(n-1)/2} + q(n), & n \text{ odd}
\end{cases}
\]

% Функция q(n)
\[
\text{with } q(n) = n 2^{2n-1} - 5 \times 2^{n-3} + \frac{1}{2} (2^n - 5n + 4)
\]

% Четвёртая функция (I_clique)
\[
I^{\text{clique}}_{\text{DPsize}}(n) =
\begin{cases}
    2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} - \frac{1}{4} \binom{n}{n/2} + 1, & n \text{ even} \\
    2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} + 1, & n \text{ odd}
\end{cases}
\]
Где \textbf{chain} - запросы соединения от n таблиц, имеющие вид цепочки. 
\textbf{Cycle, star, clique} -- цикл, звезда(одна вершина связана со многими, все остальные
между собой не имеют связей), полный граф.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\centering \subsubsection*{DPsub [https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de]} 
\raggedright
Разбивает граф соединений на подграфы, строит оптимальный порядок для каждого
компонента и соединяет их. Также не поддерживает работу с внешними соединениями.
\begin{algorithm}
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$ to be joined
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} $1 < i \leq 2^n - 1$ \textbf{ascending}}
            \State $S \gets \{ R_j \in R \mid ( \lfloor i / 2^{j-1} \rfloor \mod 2) = 1 \}$
            \For{\textbf{each} $S_1, S_2 \subset S$ \textbf{such that} $S_2 = S \setminus S_1$}
                \If{(\textbf{not} cross products $\land \neg S_1$ connected to $S_2$)}
                    \State \textbf{continue}
                \EndIf
                \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
                \If{$p_1 = \epsilon$ \textbf{or} $p_2 = \epsilon$} \textbf{continue} \EndIf
                \State $P \gets$ CreateJoinTree($p_1, p_2$)
                \If{$B[S] = \epsilon$ \textbf{or} $C(B[S]) > C(P)$}
                    \State $B[S] \gets P$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}
Перебирает всевозможные подмножества таблиц S. Разделение множество S на  $S_1$ и $S_2$, 
так же как в DPsize. Аналогично, имеются лучшие порядки соединений $p_1$ и $p_2$, 
и если дерево, построенное из $p_1$ и $p_2$ дешевле старого варианта то происходит 
замена.
\[
I^{\text{chain}}_{\text{DPsub}}(n) =
2^{n+2} - n^{2} - 3n - 4
\]

\[
I^{\text{cycle}}_{\text{DPsub}}(n) =
n2^{n} + 2^{n} - 2n^2 - 2
\]

\[
I^{\text{star}}_{\text{DPsub}}(n) =
2 \times 3^{n-1} - 2^{n}
\]

\[
I^{\text{clique}}_{\text{DPsub}}(n) =
3^n - 2^{n+1} + 1
\]

\centering \subsubsection*{DPccp [https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de][https://dsg.uwaterloo.ca/seminars/notes/Guido.pdf]}
\raggedright
Пусть дан граф соединений G = (V, E).
Введём понятие csg-cmp-pair (S1, S2) -- в графе запроса выдели $S_1$, 
$S_2$ связные непересекающиеся подграфы, такие что $S_1 \in V$ , 
$S_2 \in V/S_1$  существует между ними существует ребро( условие 
соединения).

Заметим, что если $(S_1, S_2)$ - csg-cmp-, то и $(S_2, S_1)$
-- тоже. Мы ограничим перечисление csg-cmp-pairs теми $(S_1, S_2)$, 
которые удовлетворяют условию, что $\min(S_1) < \min(S_2)$, 
где $\min(S) = s$ такое, что 
$s \in S$ и $\forall  s^{'} \in  S : s \neq s^{'} \implies  s < s^{'}$. 
Поскольку это ограничение будет действовать для всех csg-cmp-pairs, перечисляемых нашей процедурой, 
не будет вычислено ни одной дублирующей csg-cmp-pair. Как следствие, мы должны позаботиться о том, 
чтобы наша процедура динамического программирования была полной: если применяемый 
нами бинарный оператор коммутативен, то процедура построения плана для $ S_ 1 \cup S_2$ 
из планов для $S_1$ и $S_2$ должна учитывать коммутативность.

Однако это не представляет особой сложности. Очевидно, что для того, 
чтобы быть корректным, любой алгоритм динамического программирования 
должен учитывать все csg-cmp-pairs.  Таким образом, минимальное 
количество вызовов функции стоимости любого алгоритма динамического 
программирования в точности равно количеству csg-cmp-pairs для данного 
гиперграфа. Заметим, что число связных подграфов намного меньше числа 
csg-cmp-pairs. Теперь задача состоит в том, чтобы перечислить csg-cmp-pairs 
эффективно и в порядке, приемлемом для динамического программирования. 
Задача может быть выражена более конкретно. Перед перечислением csg-cmp-pair $(S_1, S_2)$, 
все csg-cmp-pairs $(S^{'}_1, S^{'}_2)$, где $S^{'}_1 \subseteq  S_1$ 
и $S^{'}_2 \subseteq  S_2$ должны быть пронумерованы.

\begin{algorithm}
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} csg-cmp-pairs $(S_1,S_2)$, S = $S_1 \cup  S_2$}
            \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
            \State $P \gets$ CreateJoinTree($p_1, p_2$)
            \If{$B[S] = \epsilon$ \textbf{or} $C(B[S]) > C(P)$}
                \State $B[S] \gets P$
            \EndIf
        \EndFor \\
        \textbf{return} $B[\{R_0, \dots, R_{n-1}\}]$
    \end{algorithmic}
\end{algorithm}

Сначала алгоритм инициализирует начальные значени $B[{R_i}] = R_i$.
Затем перебираются такие подмножества вершин $S_1$ и $S_2$, 
что $(S_1, S_2)$ -- csg-cmp-pair и $B[S_1]$, $B[S_2]$ уже известны. 
Берутся оптимальные планы $p_1$ и $p_2$ от $S_1$ и $S_2$, затем они 
соединяются. Если стоимость получившегося плана больше B[S], то 
происходит замена. Ограничения:
\begin{itemize}
    \item Не поддерживает внешние соединения, из-за разбиения на csg-cmp-pairs.
    \item Сильно зависит от эффективности поиска csg-cmp-pair.
\end{itemize}

Данная реализация возможна, только если удастся перечислить все 
csg-cmp-pairs, т.к DPccp переребирает только связные графы и их комплементарные пары.
Нужно выполнить несколько задач: 
\begin{itemize}
    \item Эффективно пронумеровать все связные графы (CSG).
    \item Не пересчитывать CSG дважды, пример (S1, S2) и (S2, S1).
    \item Эффективно находить CCP для каждой CSG.
\end{itemize}

Предварительно проведём поиск в ширину и пронумеруем все узлы:

$V = {R_0, \dots,R_{n-1}}$ -- избавимся от повторного добавления $(S_1, S_2)$ и $(S_2, S_1)$.
Пусть G = {V, E} — граф запроса.
Введём множества $B_i = {v_j | j <= i}$ и функцию соседства 
$N(V^{'}) = {v^{'} | v \in V^{'} и (v,v^{'}) \in E}$
\newline

\begin{algorithm}
    Algorithm EnumerateCsg
    \begin{algorithmic}[1]
        \For{$i = n - 1$ \textbf{to} $0$}  
            \State \textbf{emit} $u_i$;
            \State EnumerateCsgRec($G, u_i, B_i$);
        \EndFor
        \State EnumerateCsgRec($G, S, X$);
        \State $N \gets \mathcal{N}(S) \setminus X$;
        \For{\textbf{each} $S^{'} \subseteq N$ \textbf{where} $S^{'} \neq \emptyset$}
            \State \textbf{emit} $(S, S^{'})$
        \EndFor 
        \For{\textbf{each} $S^{'} \subseteq N$ \textbf{where} $S^{'} \neq \emptyset$}
            \State EnumerateCsgRec($G, (S \cup S^{'}), (X \cup N)$)
        \EndFor 
    \end{algorithmic}
\end{algorithm}

\begin{center}
    \begin{tikzpicture}
        % Определение узлов
        \node (R0) at (0,2) {$R_0$};
        \node (R1) at (-1,1) {$R_1$};
        \node (R2) at (0,1) {$R_2$};
        \node (R3) at (1,1) {$R_3$};
        \node (R4) at (0,0) {$R_4$};

        % Рёбра графа
        \draw (R0) -- (R1);
        \draw (R0) -- (R2);
        \draw (R0) -- (R3);
        \draw (R1) -- (R4);
        \draw (R2) -- (R4);
        \draw (R2) -- (R3);
    \end{tikzpicture}
\end{center}

\begin{center}
    \renewcommand{\arraystretch}{1.3} % Увеличиваем высоту строк
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{\textit{S}} & $X$ & $N$ & emit$/S$ \\ 
        \hline
        $\{4\}$ & $\{0,1,2,3,4\}$ & $\emptyset$ & \\ 
        \hline
        $\{3\}$ & $\{0,1,2,3\}$ & $\{4\}$ & $\{3,4\}$ \\ 
        \hline
        $\{2\}$ & $\{0,1,2\}$ & $\{3,4\}$ & $\{2,3\}$ \\ 
        &  &  & $\{2,4\}$ \\ 
        &  &  & $\{2,3,4\}$ \\ 
        \hline
        $\{1\}$ & $\{0,1\}$ & $\{4\}$ & $\{1,4\}$ \\ 
        \hline
        $\rightarrow \{1,4\}$ & $\{0,1,4\}$ & $\{2,3\}$ & $\{1,2,4\}$ \\ 
        &  &  & $\{1,3,4\}$ \\ 
        &  &  & $\{1,2,3,4\}$ \\ 
        \hline
        $\{0\}$ & $\{0\}$ & $\{1,2,3\}$ & $\{0,1\}$ \\ 
        &  &  & $\{0,2\}$ \\ 
        &  &  & $\{0,3\}$ \\ 
        \hline
        $\rightarrow \{0,1\}$ & $\{0,1,2,3\}$ & $\{4\}$ & $\{0,1,4\}$ \\ 
        \hline
        $\rightarrow \{0,2\}$ & $\{0,1,2,3\}$ & $\{4\}$ & $\{0,2,4\}$ \\ 
        \hline
        $\rightarrow \{0,3\}$ & $\{0,1,2,3\}$ & $\{4\}$ & $\{0,3,4\}$ \\ 
        \hline
    \end{tabular}
\end{center}


\begin{algorithm}
    Algorithm EnumerateCmp
    \begin{algorithmic}[1]
        \State \textbf{Input:} A connected query graph $G = (V, E)$, a connected subset $S_1$
        \State \textbf{Precondition:} Nodes in $V$ are numbered according to a BFS
        \State \textbf{Output:} Emits all complements $S_2$ for $S_1$ such that $(S_1, S_2)$ is a csg-cmp-pair
        \State $X \gets B_{\min(S_1)} \cup S_1$
        \State $N \gets \mathcal{N}(S) \setminus X$
        \For{\textbf{each} $u_i \in N$ \textbf{by descending} $i$}
            \State \textbf{emit} $u_i$
            \State EnumerateCmpRec($G, \{u_i\}, X \cup N$)
        \EndFor
    \end{algorithmic}
\end{algorithm}

Вместе эти алгоритмы позволяют эффективно находить ccp для каждой csg.
Сложность:
\[
I^{\text{chain}}_{\text{DPсhain}}(n) =
n^3
\]

\[
I^{\text{cycle}}_{\text{DPccp}}(n) =
n^3
\]

\[
I^{\text{star}}_{\text{DPccp}}(n) =
n2^n
\]

\[
I^{\text{clique}}_{\text{DPccp}}(n) =
3^n
\]
Можно заметить, что также как и DPsize и DPsub, DPccp не поддерживает внешние соединения.
Однако он на каждом типе графа имеет меньшую сложность и имеет более сложную
реализацию чем DPsize и DPsub.

\centering \subsubsection*{DPhyp[https://15721.courses.cs.cmu.edu/spring2020/papers/20-optimizer2/p539-moerkotte.pdf]}
\raggedright

Является улучшенной версией алгоритма DPccp для работы
с внешними соединения, которые не всегда коммутативны, а значит 
не всегда допускают переупорядочивания. Это значит, что если
мы сделаем невалидное переупорядочивание результат изменится.

\begin{center}
    \begin{tikzpicture}
        % Первое дерево
        \node {$\rightouterjoin_{A.x = C.y} $}
            child { 
                node {$\Join_{B.x = A.y}$}
                    child { node {$A$} }
                    child { node {$B$} }
            }
            child { node {$C$} };
    
        % Знак неравенства между деревьями
        \node at (3, -1.2) {\huge $\neq$};
    
        % Второе дерево
        \node at (6, 0) {$\Join_{B.x = A.y}$}
            child { 
                node {$\rightouterjoin_{A.x = C.y}$}
                    child { node {$A$} }
                    child { node {$C$} }
            }
            child { node {$B$} };
    \end{tikzpicture}
\end{center}

При работе с внешними соединениями возникает понятие гиперграфа.

\textbf{Гиперграф} -- пара (V, E), где V -- непустове множество вершин 
и E -- множество гиперрёбер. 
\textbf{Гиперребро} -- неупорядоченная пара (u, v)
непустых подмножеств V$( u \subset V и v \subset V)$, с условием $u \cap v = \emptyset$
Пусть все узлы V линейно упорядочены по отношению <.
\begin{center}
    \begin{tikzpicture}
        % Узлы
        \node (R1) at (-2,2) {$R_1$};
        \node (R2) at (-2,0) {$R_2$};
        \node (R3) at (-2,-2) {$R_3$};
        
        \node (R4) at (2,2) {$R_4$};
        \node (R5) at (2,0) {$R_5$};
        \node (R6) at (2,-2) {$R_6$};
        
        % Центральные соединения
        \node (L) at (-1,0) {};
        \node (R) at (1,0) {};
        % Линии
        \draw (R1) -- (R2);
        \draw (R2) -- (R3);
        \draw (R1) -- (L);
        \draw (R3) -- (L);
        
        \draw (R4) -- (R5);
        \draw (R5) -- (R6);
        \draw (R4) -- (R);
        \draw (R6) -- (R);
        
        \draw (L) -- (R);
    \end{tikzpicture}
\end{center}

Пример: 
$R_1.a + R_2.b + R3.c = R_4.d + R_5.e + R_6.f$ . Этому условию соединения 
соответствует гиперребро  $({R_1, R_2, R_3}, {R_4, R_5, R_6})$. $V = {R_1, \dots , R_6}$. 
Простые рёбра:  $({R_1}, {R_2}), ({R_2}, {R_3}), ({R_4}, {R_5})$ и 
$({R_5}, {R_6})$. Отшошение линейного порядка : $R_i < R_j \Leftrightarrow  i < j$.

\textbf{Подграф} -- есть гипреграф H(V, E), $V^{'} \subseteq V$ и $E^{'} = {(u, v) | (u, v) \in E, u \in V^{'} и v \in V^{'}}$.
Тогда гиперграф $G^{'} = (V^{'}, E^{'})$, порождённый $V^{'}, E^{'}$ будет подграфом.
\newline

\textbf{Связность гиперграфа} — пусть $H$ — гиперграф. $H$ связный, если $|V| = 1$ или существует разбиение $V$ на $V'$ и $V''$ и существует гиперребро $(u, v) \in E$: $u \subseteq V'$ и $v \subseteq V''$, и порождённые $V'$ и $V''$ подграфы связные. Краткое обозначение: \textbf{csg}.

\textbf{Связное дополнение} — $V' \subseteq V$, $V'' \subseteq (V \setminus V')$ и порождённые $V'$ и $V''$ подграфы связные, то $V''$ — связное дополнение $V'$. Краткое обозначение: \textbf{cmp}.

\textbf{Csg-cmp-pair для гиперграфа} — пусть $H = (V, E)$ — гиперграф, а $S_1, S_2$ — два подмножества $V$ такие, что $S_1 \subseteq V$ и $S_2 \subseteq (V \setminus S_1)$ являются связным подграфом и связным дополнением. Если существует гиперребро $(u, v) \in E$ такое, что $u \subseteq S_1$ и $v \subseteq S_2$, то мы называем $(S_1, S_2)$ \textbf{csg-cmp-pair}.

Основная идея \textbf{Dphyp} такая же, как и у \textbf{DPccp}: постепенно расширять \textbf{csg}-графы, беря новые вершины из функции соседства $N$. $N(S, X)$ при исключающем множестве $X$ состоит из всех вершин, достижимых из $S$, которые не входят в $X$. При этом, выбирая подмножества соседства для включения, мы должны рассматривать гиперузел как атомарный экземпляр: либо все его узлы находятся внутри перечисляемого подмножества, либо ни один из них.

Так как гиперузлы могут пересекаться и упорядоченность вершин важна, определим минимальный элемент множества:
\[
\min(S) = \{s \mid s \in S, \forall s' \in S: s \neq s' \Rightarrow s \prec s'\}.
\]

Для определения функции соседства $N(S, X)$ для гиперграфа определим минимальное множество $E^\downarrow$, такое, что для любого гиперребра $(u, v) \in E$ существует гиперребро $(u', v') \in E^\downarrow$, где $u' \subseteq u$ и $v' \subseteq v$.

Но для начала определим множество:
\[
E^{\downarrow'}(S, X) = \{v \mid (u, v) \in E, u \subseteq S, v \cap S = \emptyset, v \cap X = \emptyset\}.
\]
Определим $E^\downarrow (S, X)$ как минимальное множество гиперузлов, такое, что для всех $v \in E^{\downarrow'}(S, X)$ существует гиперузел $v' \in E^\downarrow (S, X)$, такой что $v' \subseteq v$.

Теперь для гиперграфа определим фукнцию соседства:
N(S, X) = $\bigcup_{v \in E^\downarrow (S, X)} \min(v)$

Перейдём к самому алгоритму DPhyp, основная идея заключается:
\begin{itemize}
    \item Алгоритм строит все ccp путём перечисления связных подграфов из возрастающей части графа запроса.
    \item Как и основные csg, так и их cmp создаются путём рекурсивного обхода графа.
    \item Во время обходя графа, некоторые узлы запрещены для посещения, чтобы избежать дублирования csg-cmp-pair.
    \item Csg увеличиваются за счёт ребёр, ведущим к соседним узлам. 
    Гиперрёбра интерпретируются как n к 1 рёбра: n рёбер с одной стороны ведут к одному узлу с другой стороны.
\end{itemize}

Алгоритм обходит граф в фиксированном порядке и рекурсивно производит более крупные связные подграфы. Но есть некоторые проблемы: 
\begin{itemize}
    \item Начальная сторона гиперребра может включать в себя несколько узлов, что усложняет построение соседства. 
    \item Конечная сторона ребра может приводить сразу к нескольким узлам, что нарушает рекурсивный рост компонентов. Поэтому алгоритм выбирает конечный узел (1 в «n к 1» ), начинает рекурсивный рост и использует таблицу DP для проверки, достигнуто ли правильное построение.
\end{itemize}
Весь алгоритм распределен по пяти подпрограммам. Подпрограмма верхнего 
уровня Solve инициализирует динамическую таблицу программирования с 
планами доступа для одиночных отношений, а затем вызывает EmitCsg 
и EnumerateCsgRec для каждого набора, содержащего ровно одно 
отношение.  EnumerateCsgRec отвечает за перечисление связных подграфов.
 Для этого она вычисляет окрестность и перебирает каждое ее 
 подмножество. Для каждого такого подмножества $S_1$ она вызывает 
 EmitCsg. Эта функция отвечает за нахождение  подходящие дополнения. 
 Для этого нужно вызвать EnumerateCmpRec, который рекурсивно перечисляет 
 дополнения $S_2$ для найденного ранее связного подграфа $S_1$. 
 Пара $(S_1, S_2)$ является csg-cmp-pair. Для каждой такой пары 
 вызывается программа EmitCsgCmp. Ее основная задача -- рассмотреть 
 план, построенный из планов для $S_1$  и $S_2$.


\begin{algorithm}
    \begin{algorithmic}[1]
        \State Solve()
        \For{each $u \in V$}
            \State dpTabele[${u}$] = plan for u
        \EndFor
        \For{each $u \in V$ descending according to <}
            \State EmitCsg({u}) - process singleton sets
            \State EnumerateCsgRec({u},$B_u$) - expand singleton sets
        \EndFor
        return dpTabele[V]
    \end{algorithmic}
\end{algorithm}

\begin{center}
    \begin{tikzpicture}
        % Серые узлы
        \node[gray] at (-3,1) {$R_1$};
        \node[gray] at (-1,1) {$R4$};
        \node[gray] at (1,1) {$R_1$};
        \node[gray] at (3,1) {$R_4$};

        \node[gray] at (-3,0) {$R_2$};
        \node[gray] at (-1,0) {$R_5$};
        \node[gray] at (1,0) {$R_2$};
        \node[gray] at (3,0) {$R_5$};

        \node[gray] at (-3,-1) {$R_3$};
        \node[gray] at (1,-1) {$R_3$};

        % Выделенные узлы
        \node[draw, rectangle] at (-1,-1) {\textbf{$R_6$}};
        \node[draw, rectangle] at (3,0) {\textbf{$R_5$}};
        \node at (3,-1) {\textit{$R_6$}};

        % Номера 1 и 2
        \node at (-1,-2) {\large 1};
        \node at (2.5,-2) {\large 2};
    \end{tikzpicture}
\end{center}

\begin{center}
    \begin{tikzpicture}
        % Связный подграф (с рамкой)
        \draw (-0.3,0.3) rectangle (1.3,-0.3);
        \node at (0,0) {$R_1$};
        \node at (1,0) {$R_2$};
        \draw (0.2,0) -- (0.8,0);

        % Подпись
        \node[right] at (1.5,0) {связный подграф};

        % Связанное дополнение (пунктир)
        \draw[dashed] (-0.3,-0.8) rectangle (1.3,-1.4);
        \node at (0,-1) {$R_1$};
        \node at (1,-1) {$R_2$};
        \draw[dashed] (0.2,-1) -- (0.8,-1);

        % Подпись
        \node[right] at (1.5,-1) {связанное дополнение};

        % Запрещённый узел (серый)
        \node[gray] at (7,0) {$R_1$};
        \node[right] at (7.5,0) {запрещённый узел};

        % Незапрещённый узел (чёрный)
        \node at (7,-1) {$R_1$};
        \node[right] at (7.5,-1) {незапрещённый узел};
    \end{tikzpicture}
\end{center}

В первом цикле инициализируется таблица ДП с планами для одиночных отношений.  
Во втором цикле для каждого узла графа запросов в порядке убывания (согласно $\prec$)  
вызываются две подпрограммы \texttt{EmitCsg} и \texttt{EnumerateCsgRec}.  

Алгоритм вызывает \texttt{EmitCsg}$(\{v\})$ для отдельных вершин $v \in V$,  
чтобы сгенерировать все \textbf{csg-cmp-pairs} $(\{v\}, S_2)$ через вызовы  
\texttt{EnumerateCsgCmp} и \texttt{EmitCsgCmp}, где $v \prec \min(S_2)$.  

Это условие подразумевает, что каждая \textbf{csg-cmp-pair} генерируется только один раз,  
и симметричные пары не генерируются.  

Это соответствует одновершинным графам, например, шаг 1 и 2.

Вызовы \texttt{EnumerateCsgRec} расширяют исходное множество $\{v\}$  
в большие множества $S_1$, для которых затем находятся связные подмножества  
его дополнения $S_2$, такие, что $(S_1, S_2)$ приводит к \textbf{csg-cmp-pair}.  

На шаге 2, где \texttt{EnumerateCsgRec} начинается с $R_5$  
и расширяет его до $\{R_5, R_6\}$ на шаге 4  
(шаг 3 — это построение дополнения).

\begin{center}
    \begin{tikzpicture}
        \node[gray] at (-6,3) {$R_1$};
        \node[gray] at (-6,2) {$R_2$};
        \node[gray] at (-6,1) {$R_3$};
        \node[gray] at (-4,3) {$R_4$};
        \node at (-4,2) {$R_5$};
        \node at (-4,1) {$R_6$};
        \node at (-5,0) {\large 2};
        \node[draw, rectangle] at (-4,2) {\textbf{$R_5$}};

        \node[gray] at (-6+4,3) {$R_1$};
        \node[gray] at (-6+4,2) {$R_2$};
        \node[gray] at (-6+4,1) {$R_3$};
        \node[gray] at (-4+4,3) {$R_4$};
        \node at (-4+4,2) {$R_5$};
        \node at (-4+4,1) {$R_6$};
        \node[draw, rectangle] at (-4+4,2) {\textbf{$R_5$}};
        \node[draw, dashed] at (-4+4,1) {\textit{$R_6$}};
        \draw (-4+4,1) -- (-4+4,2);
        \node at (-5+4,0) {\large 3};

        \node[gray] at (-6+8,3) {$R_1$};
        \node[gray] at (-6+8,2) {$R_2$};
        \node[gray] at (-6+8,1) {$R_3$};
        \node[gray] at (-4+8,3) {$R_4$};
        \node at (-4+8,2) {$R_5$};
        \node at (-4+8,1) {$R_6$};
        \draw (-4+8,1) -- (-4+8,2);
        \node at (-5+8,0) {\large 4};
        \draw (-3.5+8,2.5) rectangle (-4.5+8,0.5);
    \end{tikzpicture}
\end{center}

Чтобы избежать дублирования при перечислении, все узлы, которые 
упорядочены перед v согласно < , запрещены при рекурсивном 
расширении. Формально мы определяем это множество как $B_v={w | w < v} \cup {v}$.

\begin{algorithm}
    EnumerateCsgRec($S_1$, X)
    \begin{algorithmic}[1]
        \For{each $N \subseteq \mathcal{N}(S_1, X): N \neq \emptyset$}
            \If{$dpTable[S_1 \cup N]$}
                \State EmitCsg($S_1 \cup N$)
            \EndIf
        \EndFor
        \For{each $N \subseteq \mathcal{N}(S_1, X): N \neq \emptyset$}
            \State EnumerateCsgRec($S_1 \cup N,X \cup \mathcal{N}(S_1, X)$)
        \EndFor
    \end{algorithmic}
\end{algorithm}

Цель \texttt{EnumerateCsgRec} — расширить заданное множество $S_1$,  
которое индуцирует связный подграф $G$, до большего множества с тем же свойством.  
Для этого рассматривается каждое непустое подходящее подмножество окрестности $S_1$.  

Для каждого из этих подмножеств $N$ проверяется,  
является ли $S_1 \cup N$ связной компонентой.  
Это делается с помощью поиска в таблице \texttt{dpTable}.  
Если проверка прошла успешно, то найден новый связный компонент,  
который далее обрабатывается вызовом \texttt{EmitCsg}$(S_1 \cup N)$.  

Затем, на втором этапе, для всех этих подмножеств $N$ окрестности  
мы вызываем \texttt{EnumerateCsgRec} так,  
что $S_1 \cup N$ может быть рекурсивно расширен.  

Причина, по которой мы сначала вызываем \texttt{EmitCsg},  
а затем \texttt{EnumerateCsgRec}, заключается в том,  
что для того, чтобы иметь последовательность перечислений,  
действительную для динамического программирования,  
сначала должны быть сгенерированы меньшие наборы.  

\begin{center}
    \begin{tikzpicture}
        \node[gray] at (-6,3) {$R_1$};
        \node at (-6,2) {$R_2$};
        \node at (-6,1) {$R_3$};
        \node at (-4,3) {$R_4$};
        \node at (-4,2) {$R_5$};
        \node at (-4,1) {$R_6$};
        \node at (-5,0) {\large 12};
        \node[draw, rectangle] at (-6,2) {\textbf{$R_2$}};

        \node[gray] at (-6+4,3) {$R_1$};
        \node at (-6+4,2) {$R_2$};
        \node at (-6+4,1) {$R_3$};
        \node at (-4+4,3) {$R_4$};
        \node at (-4+4,2) {$R_5$};
        \node at (-4+4,1) {$R_6$};
        \node[draw, rectangle] at (-6+4,2) {\textbf{$R_2$}};
        \node[draw, dashed] at (-6+4,1) {\textit{$R_3$}};
        \draw (-6+4,1) -- (-6+4,2);
        \node at (-5+4,0) {\large 13};

        \node[gray] at (-6+8,3) {$R_1$};
        \node at (-6+8,2) {$R_2$};
        \node at (-6+8,1) {$R_3$};
        \node at (-4+8,3) {$R_4$};
        \node at (-4+8,2) {$R_5$};
        \node at (-4+8,1) {$R_6$};
        \draw (-6+8,1) -- (-6+8,2);
        \node at (-5+8,0) {\large 14};
        \draw (-5.5+8,2.5) rectangle (-6.5+8,0.5);
    \end{tikzpicture}
\end{center}

На шаге 12 был сгенерирован \texttt{Solve} на $S_1 = \{R_2\}$.  
Окрестность состоит только из $\{R_3\}$, так как $R_1$ находится в $X$  
($R_4, R_5, R_6$ тоже не в $X$, так как не достижимы).  

\texttt{EnumerateCsgRec} сначала вызывает \texttt{EmitCsg},  
который создаст присоединяемое дополнение (шаг 13).  
Затем он проверяет $\{R_2, R_3\}$ на связность.  

Соответствующая запись в \texttt{dpTable} была сгенерирована на шаге 13.  
Следовательно, этот тест проходит успешно,  
и $\{R_2, R_3\}$ далее обрабатывается рекурсивным вызовом  
\texttt{EnumerateCsgRec} (шаг 14).  

Теперь расширение останавливается, так как окрестность $\{R_2, R_3\}$ пуста,  
поскольку $R_1 \in X$.  

\begin{algorithm}
    EmitCsg($S_1$)
    \begin{algorithmic}[1]
        \State X = $S_1 \cup B_{min(S_1)}$
        \State N = $\mathcal{N}(S_1, X)$
        \For{each $u \in N$ descending according to <}
            \State $S_2$ = {u}
            \If{$\exists (u,v) \in E: u \subseteq S_1 \cap v \subseteq S_2$}
                \State EmitCsgCmp($S_1, S_2$)
            \EndIf
            \State EnumerateCmpRec($S_1,S_2,X$)
        \EndFor
    \end{algorithmic}
\end{algorithm}

\texttt{EmitCsg} принимает в качестве аргумента непустое подходящее подмножество $S_1$ из $V$,  
которое индуцирует связный подграф.  
Его задача — сгенерировать все узлы $S_2$, такие,  
что $(S_1, S_2)$ становится \textbf{csg-cmp-pair}.  

Неудивительно, что узлы берутся из окрестности $S_1$.  
Все узлы, которые упорядочивались до наименьшего элемента в $S_1$  
(охваченного множеством $B_{\min}(S_1)$), удаляются из окрестности,  
чтобы избежать дублирования перечислений \cite{17}.  

Поскольку окрестность также содержит $\min(v)$  
для гиперрёбер $(u, v)$ с $|v| > 1$,  
то не гарантируется, что $S_1$ соединён с $v$.  
Чтобы избежать генерации ложных \textbf{csg-cmp-pairs},  
\texttt{EmitCsg} проверяет их на связность.  

Однако каждый атомарный сосед может быть расширен  
до действительного дополнения $S_2$ к $S_1$.  
Поэтому перед вызовом \texttt{EnumerateCmpRec},  
который выполняет это расширение, такая проверка не требуется.  

\begin{center}
    \begin{tikzpicture}
        \node at (-6,3) {$R_1$};
        \node at (-6,2) {$R_2$};
        \node at (-6,1) {$R_3$};
        \node at (-4,3) {$R_4$};
        \node at (-4,2) {$R_5$};
        \node at (-4,1) {$R_6$};
        \draw (-6,1) -- (-6,2);
        \draw (-6,2) -- (-6,3);
        \node at (-5,0) {\large 20};
        \draw (-5.5,3.5) rectangle (-6.5,0.5);

        \node at (-6+4,3) {$R_1$};
        \node at (-6+4,2) {$R_2$};
        \node at (-6+4,1) {$R_3$};
        \node at (-4+5,3) {$R_4$};
        \node at (-4+5,2) {$R_5$};
        \node at (-4+5,1) {$R_6$};
        \draw (-6+4,1) -- (-6+4,2);
        \draw (-6+4,2) -- (-6+4,3);
        \node at (-5+4,0) {\large 21};
        \draw (-5.5+4,3.5) rectangle (-6.5+4,0.5);
        \node[draw, dashed] at (-4+5,3) {\textit{$R_4$}};

        % Центральные соединения
        \node (L) at (-1,2) {};
        \node (R) at (0,2) {};
        % Линии
        \draw (-6+4,3) -- (L);
        \draw (-6+4,1) -- (L);
        
        \draw (-4+5,3) -- (R);
        \draw (-4+5,1) -- (R);
        
        \draw (L) -- (R);
    \end{tikzpicture}
\end{center}

Посмотрите на шаг 20.  
Текущий набор $S_1 = \{R_1, R_2, R_3\}$, а $N = \{R_4\}$.  
Поскольку нет гиперребра, соединяющего эти два множества,  
вызов \texttt{EmitCsgCmp} не требуется.  

Однако множество $\{R_4\}$ может быть расширено  
до допустимого дополнения, а именно $\{R_4, R_5, R_6\}$.  
Подходящее узловое семя дополнения является задачей вызова  
\texttt{EnumerateCmpRec} на шаге 21.  

\begin{algorithm}
    EnumerateCmpRec($S_1, S_2, X$)
    \begin{algorithmic}[1]
        \ForAll{$N \subseteq \mathcal{N}(S_2, X) \colon N \neq \emptyset$}
            \If{$\texttt{dpTable}[S_2 \cup N] \neq \emptyset \;\land$  
                $\exists (u, v) \in E \colon u \subseteq S_1 \;\land\; v \subseteq S_2 \cup N$}
                \State \texttt{EmitCsgCmp}($S_1, S_2 \cup N$)
            \EndIf
        \EndFor
        \State $X \gets X \cup \mathcal{N}(S_2, X)$
        \ForAll{$N \subseteq \mathcal{N}(S_2, X) \colon N \neq \emptyset$}
            \State \Call{EnumerateCmpRec}{$S_1, S_2 \cup N, X$}
        \EndFor
    \end{algorithmic}
\end{algorithm}

\texttt{EnumerateCsgRec} имеет три параметра.  
Первый параметр $S_1$ используется только для передачи его в \texttt{EmitCsgCmp}.  

Второй параметр — это множество $S_2$,  
которое является связным и должно расширяться до тех пор,  
пока не будет достигнута допустимая \textbf{csg-cmp-pair}.  
Поэтому рассматривается окрестность $S_2$.  

Для каждого непустого подходящего подмножества $N$ окрестности  
проверяется, является ли $S_2 \cup N$ связным подмножеством  
и соединённым с $S_1$.  

Если да, то мы имеем корректную \textbf{csg-cmp-pair} $(S_1, S_2)$  
и можем приступить к построению плана  
(это делается в \texttt{EmitCsgCmp}).  

Независимо от результата проверки,  
мы рекурсивно пытаемся расширить $S_2$,  
так чтобы эта проверка оказалась успешной.  

В целом, \texttt{EnumerateCmpRec} ведёт себя очень похоже  
на \texttt{EnumerateCsgRec}.  

\begin{center}
    \begin{tikzpicture}
        \node at (-6,3) {$R_1$};
        \node at (-6,2) {$R_2$};
        \node at (-6,1) {$R_3$};
        \node at (-4+1,3) {$R_4$};
        \node at (-4+1,2) {$R_5$};
        \node at (-4+1,1) {$R_6$};
        \draw (-6,1) -- (-6,2);
        \draw (-6,2) -- (-6,3);
        \node at (-5,0) {\large 21};
        \draw (-5.5,3.5) rectangle (-6.5,0.5);
        \node[draw, dashed] at (-4+1,3) {\textit{$R_4$}};
        \node (L) at (-5,2) {};
        \node (R) at (-4,2) {};
        \draw (-6,3) -- (-5,2);
        \draw (-6,1) -- (-5,2);
        \draw (-4+1,3) -- (-4,2);
        \draw (-4+1,1) -- (-4,2);
        \draw (-5,2) -- (-4,2);

        \node at (-6+5,3) {$R_1$};
        \node at (-6+5,2) {$R_2$};
        \node at (-6+5,1) {$R_3$};
        \node at (-4+1+5,3) {$R_4$};
        \node at (-4+1+5,2) {$R_5$};
        \node at (-4+1+5,1) {$R_6$};
        \draw (-6+5,1) -- (-6+5,2);
        \draw (-6+5,2) -- (-6+5,3);
        \node at (-5+5,0) {\large 22};
        \draw (-5.5+5,3.5) rectangle (-6.5+5,0.5);
        \node[draw, dashed] at (-4+1+5,3) {\textit{$R_4$}};
        \node (L) at (-5+5,2) {};
        \node (R) at (-4+5,2) {};
        \draw (-6+5,3) -- (-5+5,2);
        \draw (-6+5,1) -- (-5+5,2);
        \draw (-4+1+5,3) -- (-4+5,2);
        \draw (-4+1+5,1) -- (-4+5,2);
        \draw (-5+5,2) -- (-4+5,2);

        \node at (-6+10,3) {$R_1$};
        \node at (-6+10,2) {$R_2$};
        \node at (-6+10,1) {$R_3$};
        \node at (-4+1+10,3) {$R_4$};
        \node at (-4+1+10,2) {$R_5$};
        \node at (-4+1+10,1) {$R_6$};
        \draw (-6+10,1) -- (-6+10,2);
        \draw (-6+10,2) -- (-6+10,3);
        \node at (-5+10,0) {\large 23};
        \draw (-5.5+10,3.5) rectangle (-6.5+10,0.5);
        \node[draw, dashed] at (-4+1+10,3) {\textit{$R_4$}};
        \node (L) at (-5+10,2) {};
        \node (R) at (-4+10,2) {};
        \draw (-6+10,3) -- (-5+10,2);
        \draw (-6+10,1) -- (-5+10,2);
        \draw (-4+1+10,3) -- (-4+10,2);
        \draw (-4+1+10,1) -- (-4+10,2);
        \draw (-5+10,2) -- (-4+10,2);
    \end{tikzpicture}
\end{center}

Снова посмотрите на шаг 21.  
$S_1 = \{R_1, R_2, R_3\}$ и $S_2 = \{R_4\}$.  
$N = \{R_5\}$.  

Множество $\{R_4, R_5\}$ индуцирует связный подграф.  
Он был вставлен в \texttt{dpTable} на шаге 6.  
Однако не существует гиперребра, соединяющего его с $S_1$.  
Следовательно, вызов \texttt{EmitCsgCmp} не производится.  

Далее следует рекурсивный вызов на шаге 22  
с изменением $S_2$ на $\{R_4, R_5\}$.  
Его окрестностью является $\{R_6\}$.  
Множество $\{R_4, R_5, R_6\}$ приводит к связному подграфу.  

Соответствующий тест через поиск в \texttt{dpTable} проходит успешно,  
так как соответствующая запись была сгенерирована на шаге 7.  
Вторая часть проверки также успешна,  
так как наш единственный истинный гиперребро соединяет это множество с $S_1$.  

Следовательно, вызов \texttt{EmitCsgCmp} на шаге 23 происходит  
и генерирует планы, содержащие все отношения.  

\begin{algorithm}
    EmitCsgCmp($S_1, S_2$)
    \begin{algorithmic}[1]
            \State $\text{plan}_1 = \texttt{dpTable}[S_1]$
            \State $\text{plan}_2 = \texttt{dpTable}[S_2]$
            \State $S = S_1 \cup S_2$
            \State $p = \bigwedge_{(u_1, u_2) \in E, u_i \subseteq S_i} \mathcal{P}(u_1, u_2)$
            \State $\text{newplan} = \text{plan}_1 \Join_p \text{plan}_2$
            \If{$\texttt{dpTable}[S] = \emptyset \;\lor\; \text{cost}(\text{newplan}) < \text{cost}(\texttt{dpTable}[S])$}
                \State $\texttt{dpTable}[S] = \text{newplan}$
            \EndIf
            \State $\text{newplan} = \text{plan}_2 \Join_p \text{plan}_1$ \quad // for commutative ops only
            \If{$\text{cost}(\text{newplan}) < \texttt{dpTable}[S]$}
                \State $\texttt{dpTable}[S] = \text{newplan}$
            \EndIf
    \end{algorithmic}
\end{algorithm}

Задача \texttt{EmitCsgCmp}$(S_1, S_2)$ — соединить оптимальные планы  
для $S_1$ и $S_2$, которые должны образовать \textbf{csg-cmp}-пару.  

Для этого мы должны быть в состоянии вычислить  
правильный предикат соединения и затраты на результирующие соединения.  
Для этого необходимо, чтобы предикаты присоединения,  
селективности и кардинальности были привязаны к гиперграфу.  

Поскольку мы скрываем вычисления стоимости  
в абстрактной функции \texttt{cost},  
нам нужно только явно собрать предикат соединения.  

Для данного гиперграфа $G = (V, E)$  
и гиперребра $(u, v) \in E$,  
определим $\mathcal{P}(u, v)$ —  
условие соединения по этому ребру.  

Сначала из таблицы динамического программирования  
извлекаются оптимальные планы для $S_1$ и $S_2$.  
Затем мы запоминаем в $S$ общее множество отношений,  
присутствующих в плане, который необходимо построить.  

Предикат соединения $p$ собирается  
путём взятия конъюнкции предикатов тех гиперграниц,  
которые соединяют $S_1$ и $S_2$.  

Затем планы строятся,  
и если они дешевле существующих,  
они сохраняются в \texttt{dpTable}.

Таким образом DPhyp, является относительно( DPsize, DPsub) эффективным алгоритмом.
При этом позволяет обрабатывать внешние соединения.

Тем не менее, когда количество таблиц для соединения становится большим(например >15) все алгоритмы динамического 
программирования начинают работать непозволительно долго. При этом в современном мире зачастую встречаются запросы, 
содержащие большое количество соединений таблиц ( например фильтры поиска в интернет магазинах или каталогах). Для решения 
таких задач прибегают к использованию двух техник: эвристические алгоритмы( будут описаны позже) и линеаризацию пространства 
поиска для алгоритмов динамического программирования (современный подход).
[https://db.in.tum.de/~radke/papers/lindp++.pdf]

Данный подход являяется развитием линеаризованного DP(LinDP)[https://db.in.tum.de/~radke/papers/hugejoins.pdf] для работы с 
гиперграфами. Идея linDP состоит в том,  сначала выбрав хороший (в идеале оптимальный)
относительный порядок отношений, а затем использовать полиномиальный по времени шаг DP
для построения оптимального кустового дерева для этого относительного порядка. Изначальный 
порядок строится алгоритмом IK/KBZ[IK84, KBZ86], который строит левостороннее дерево порядка c близким 
к оптимальному порядку за O($n^2$). Однако алгоритм IK/KBZ не поддерживает внешние соединения и графы с запросов с циклами.
Во втором случае строится минимальное остовное дерева, в котором убирают рёбра с наименьшей селективностью.
На следующем шаге за O($n^3$) строится близкое к оптимальное кустовое дерево.

Для начала введём важные определения:
Пусть дан граф $G = (V, E)$, и начальное отношение
$R_k$. Построим ориентированный \textbf{граф предшествования}
$G^{P}_k$ = $(V^{P}_k, E^{P}_k)$  с корнем в $R_k$:

\begin{itemize}
    \item Выберем $R_k$ как корневой узел в $G^{P}_k$, $V^{P}_k = {R_k}$
    \item Пока $|V^{P}_k| < |V|$, выберем 
    $R_i \in V \setminus V^{P}_k$ такой, что $\exists R_j \in V^{P}_k : (R_j, R_i) \in E$.
    Добавим $R_i$ в $V^{P}_k$ и добавим $(R_j, R_i)$ в $E^{P}_k$
\end{itemize}

Граф предшествования по сути вводит упорядочивание соединений.

Пусть $A$ и $B$ — две последовательности, а $V$ и $U$ — две непустые последовательности.  
Мы говорим, что функция стоимости $C$ обладает \textit{свойством перестановки смежных последовательностей}  
(ASI-свойством), если и только если существует функция $T$ и ранговая функция, определённая как  
\[
\text{rank}(S) = \frac{T(S) - 1}{C(S)}
\]
такое, что выполняется следующее:
\[
C(AUVB) \leq C(AVUB) \iff \text{rank}(U) \leq \text{rank}(V)
\]
если $AUVB$ и $AVUB$ удовлетворяют ограничениям предшествования,  
заданным некоторым графом предшествования.

\centering TODO

Все расмотренные алгоритмы порождали планы в виде ветвистых деревьев, так как они 
в отличие от односторонних деревьев позволяют использовать преимущества параллелизма.
Исполнение можно распараллелить, если они не зависят друг от друга, т.е 
соединения A и B можно выполнить параллельно, если на любом пути от корня 
до таблицы нету одновременно A и B. Такого нельзя добиться на односторонних 
деревьях.


Рассмотрим теперь эвристические методы планирования запросов. Применяемые когда количество
таблиц в запросе велико.

\centering \subsubsection*{GOO(Greedy Operator Order) [https://db.in.tum.de/teaching/ws2425/queryopt/main.pdf?lang=de][https://dsg.uwaterloo.ca/seminars/notes/Guido.pdf]}
\raggedright

GOO $[https://wwwiti.cs.uni-magdeburg.de/iti_db/publikationen/ps/auto/thesisAllam19.pdf ]$ -- 

жадный алгоритм, который выбирает локально( не рассматривает все  варианты порядка соединений) 
оптимальное соединение на каждом этапе, формируя 
итоговый порядок соединений таблиц шаг за шагом. Выходное
дерево соединений произвольное, т.е может быть либо ветвистым или односторонним.
\begin{itemize}
    \item На каждом шаге выбираем два отношения, которых выгоднее всего соединить. За стоимость таблиц i и j можно взять селективность Sel[i,j]
    cost(i,j) = size(i) * size(j) * Sel[i, j].
    \item Объединяем их в одно поддерево.
    \item Повторяем процесс, пока не останется одно дерево соединений.
\end{itemize}

\begin{algorithm}
    GOO
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$
        \State \textbf{Output:} An roughly optimal join tree
        \State T = R
        \While{|T| > 1}
            \State select $(T_i,T_j)$ = $arg \min_{T_i, T_j \in T, T_i \neq T_j} cost(T_i, T_j)$
            \State $T = T \setminus {T_i, T_j}$
            \State $T = T \cup {T_i \Join T_j}$
        \EndWhile \\
        return $T_0$
    \end{algorithmic}
\end{algorithm}

Данный алгоритм просто в реализации и имеет сложность O($n^3$), не поддерживает
внешние соединения.

\centering \subsubsection*{\textbf{Генетический алгоритм}}
\raggedright  

Это эволюционный метод, который использует принципы естественного отбора и мутаций для поиска оптимального порядка соединений.  

\begin{enumerate}
    \item \textbf{Генерация начальной популяции} – создаётся множество случайных порядков соединений таблиц ("хромосом").
    \item \textbf{Оценка приспособленности} – измеряется стоимость каждого порядка соединений.
    \item \textbf{Скрещивание} – комбинируются части выживших порядков соединений, создавая новые последовательности.
    \item \textbf{Мутация (mutation)} – небольшие случайные изменения в порядке соединений для поиска лучших решений.
    \item \textbf{Выбор новых решений} – на каждом этапе остаются только наиболее эффективные планы соединений.
    \item \textbf{Повторение} 1--5 определённое количество итераций, и выбор самого приспособленного из выживших.
\end{enumerate}

Рассмотрим теперь реализацию работы планировщика в \textbf{PostgreSQL}.


\end{flushleft}
\end{document}
